<center>
    <h1>
        Problem Set 8
    </h1>
    <p1>人工智能学院 201300096 杜兴豪</p1>
</center>
### Problem 1















### Problem 2

证明：

​		$n$次`MakeSet`操作会构建$n$个仅含有一个根节点的单点树。

​		接下来的$m$ 次`Union`和`Find`操作中，如果率先使用$k$次`Union`操作，将其合并为一棵高度为$\Theta(\log n)$的树结构，然后用剩下的 $m-k$ 次操作`Find`距离根节点最远的叶节点，每次时间复杂度均为$\Theta(\log n)$，则可以得到符合题目要求的一个操作序列。

​		生成这种树的方式如下：每次`Union`操作使用两个相同高度的树进行合并，得到一个高度加一的新树，因此这种树的高度是$\Theta(\log n)$的。

​		因为最后的生成树中每一个节点有且仅有1个父节点，即节点数为n的树中有且仅有$n$条边（指向自己的根节点的边也算），并且每次`Union`操作只生成1条指向根节点的边，因此要生成这样一棵树必须经过 $k=n$ 次操作，因此总共花费时间复杂度为
$$
T=kO(\log n)+(m-n)\Theta(\log n)\ge\frac12m\Theta(\log n)=\Omega(m\log n)
$$

### Problem 3

#### (a)

当输入集合为一条链时，每次查找都从当前点到根节点，总查找时间为$\sum\limits^n_{i=1}i=O(n^2)$即最坏情况下`Find`操作时间复杂度为$O(n^2)$

#### (b)

证明：

​		在使用路径压缩的`Find`操作中，对一个距离根较远的节点进行操作后，原先在它和根之间的点再进行`Find`操作均只需要$O(1)$时间就可以做到（到根的距离变为1了）。假设最远节点到根的距离为 $ k$ ，则这些节点的平均时间复杂度为
$$
\hat t=\frac{(k-1)O(1)+O(k)}{k}=\frac{O(k)}{k}=O(1)
$$
因此，在对所有节点进行查找的过程中，总的均摊时间复杂度不超过$O(1)$，

因此，上述步骤中所花费时间复杂度为
$$
T=\sum^n_{i=1}t_i\le\sum^n_{i=1}\hat t=nO(1)=O(n)
$$

### Problem 4





















### Problem 5

证明：

​	归纳奠基：当 $n=2$ 时，易知该图仅含有一条边，该边两定点分别为1度。

​	归纳假设：假设当 $n\le k$ 时题述性质成立。

​	归纳步骤：当 $n=k+1$ 时，由于该图中无环，那么删去图中任意一顶点，将把图分为两个连通分支，大小均为 $n'\le k$ ，由归纳假设，这两个连通分支中均各含有两个1度顶点。又因为一条边最多只能改变两个点的度数，因此最少剩余两个一度顶点，归纳成立。

### Problem 6

令$M=BB^T=(m_{ij})$

则：

1. $m_{ii}=\sum\limits^{|E|}_{k=1}b_{ik}^2$，即主对角线元素为所有和顶点$i$相关的边的数量之和。

2. $m_{ij}=\sum^{|E|}_{k=1}b_{ik}b_{jk}$，即从j点到i点的入度，若值为-k则表示从j点射向i点净剩余k个条边（两条方向相反的边被抵消）