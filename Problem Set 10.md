<center>
    <h1>
        Problem Set 10
    </h1>
    <p1>人工智能学院 201300096 杜兴豪</p1>
</center>

### Problem 1

#### 	算法描述

​			从给定点 $s$开始，使用DFS算法对DAG $G$进行拓扑排序，记录每个点的入度。最终的路径数为从起点$s$出发开始沿拓扑排序顺序达到$t$的路径上所有点的入度之积。（不包含起点$s$，或将$s$的入度默认为1）

​			所需改动只是在DFS中，当确定每两个顶点的前后关系时，给树边的后节点维护一个$ParentCnt$成员（每次+1）

#### 	伪代码

```
CountPath(G,s,t):
nodelist = TopoSort(G)
flag = false	//flag是用来指示这一段点集是否在s和t之间
path = 0
for node in nodelist
	if(node == s)	
		flag = true
		path = 1	//若路径中没有出现s点，则一定返回0
	else if(node == t)	
		flag = false
	if(flag && node != s)
		path *= node.ParentCnt	//若路径中又出现了新的头结点，则仍然返回0
return path
```

#### 	时间复杂度分析

​			在建立拓扑排序的时候使用DFS算法，时间复杂度为$O(|V|+|E|)$，按点遍历集合，每次循环中用$O(1)$，则总时间复杂度为$O(|V|+|E|)+O(|V|)\times O(1)=O(|V|+|E|)$

### Problem 2

#### 	算法描述

   1. 使用Tarjan的算法计算强连通分量数，并给所有点打上根节点标记，再添加可变长数组$nodes[]$，用来按照连通分支顺序存放所有的节点。

      $nodes:$在给各连通分支中所有点设置根节点为v时将所有点放入（v是该连通分支第一个被放入$nodes$的节点），或发现v为一个单点连通分支时将v放入即可

   2. 遍历$nodes$集合，将每一组点$u,v$（u,v均在同一连通分支）生成新边$(u,v)放入E'中$

      #### 伪代码

```
Rebuild(G):
roots, nodes are empty arrays
Tarjan(G) //此时已经将所有连通分支的根节点装入roots,并且所有点均在nodes中
node u = nodes[0]
for v in nodes
	if(u.root == v.root)
		E'.add((u.v))
	u = v
return (G.V, E')
```

#### 	时间复杂度分析

​			$Tarjan$的找强连通分支算法消耗时间复杂度$O(|V|+|E|)$。在循环中，遍历所有边一次，花费时间复杂度$O(|V|)$，因此总时间复杂度为$O(|V|+|E|)$

### Problem 3

#### (a)

##### 问题的图论化解读：

​		在有向连通图G中，证明对任意两点$u,v$都有从$u到v$的一条路径

##### 解释如何线性时间解决：

​		随机选择顶点$r$，以r为根节点可以以线性时间跑出一棵生成树来（如果这棵生成树并不能包含所有顶点，那直接返回结论错误）

​		然后将所有边反向，即将$边集E中所有(u,v)删除，并加入(v,u)$，也使用不到线性时间就可以完成，此时再以$r$为根跑出一棵生成树来，若这棵树仍然包含所有顶点，则返回正确，否则结论错误。

​		上述涉及的操作均为线性时间。

#### (b)

##### 问题的图论化解读：

​		在有向连通图G中，证明从给定点$r$出发，所到达的任意顶点均有一条路径返回$r$

##### 解释如何线性时间解决：

​		随机选择顶点$r$，以r为根节点可以以线性时间跑出一棵生成树来，记录生成树中的所有顶点到集合$S$。

​		然后将所有边反向，即将$边集E中所有(u,v)删除，并加入(v,u)$，也使用不到线性时间就可以完成，此时再以$r$为根跑出一棵生成树来，若这棵树仍然包含$S$中所有顶点，则返回正确，否则结论错误。

​		上述涉及的操作均为线性时间。

### Problem 4

#### (a)













#### (b)

证明：

​	若$G_I$中含有这样的连通分支，由定义知$G_I中有一条x\to \cdots\to\overline x,同时有\overline x\to\cdots\to x$

​	$也即上述和取范式中含有项可以化简为x\to\overline x\iff \overline x\or \overline x=\overline x$

​	且含有项可以化简为$\overline x\to x\iff x\or x=x$

​	因此该和取范式一定含有两项使得$x\and \overline x=false$

​	原和取范式永假，故没有可满足的赋值。

#### (c)

证明：按照(d)的赋值方法，因为没有连通分支同时含有$x和\overline x$，所以这样的遍历是不会出现矛盾的。假设将x赋值为true，则$\overline x$一定是false。考虑如果$x\to u,\overline u\to\overline x这样的情况$存在，即若将x,u均设为true，则后者全为false，原式不成立。因为$x\to u$存在，所以$\overline u\to x$也在图中，同理$x\to \overline u$也存在

$\therefore (x\to\overline u,\overline u\to x)\to x\to\overline x$存在，而原式中不应该存在这样的矛盾，矛盾

$\therefore $ 一定可以赋值成功

#### (d)

#### 	算法描述

​	使用$Tarjan$算法在线性时间内找出所有的连通分支，用并查集存放。然后从根出发，把路径上所有没有赋值的点的值设为true（当把$x设置为true时，同时将\overline x设置为false$），当遍历完所有路径之后，完成赋值

### Problem 5

#### (a)

​	证明：

​		假设仍存在另一个最小生成树。则二者之间至少存在两条边不同，（若只有一条边不同，因为每条边权重不同，所以不可能有这样的边存在。）假设原树中这两条边为$u,v$，新树中为$u',v'$，分别连接两个不同的连通分支$a,b和c,d$，则有$u+v=u'+v'$

​		$\because u\neq u',v\neq v'$

​		$\therefore u<u',v>v'或u>u',v<v'$，

​		但在两种情况下都有选择，可以使得出现更小的生成树：$1.u+v'<u+v\ 或\ 2.u'+v<u+v$

​		$\therefore$ 矛盾。多边不同的情况分析与之类似，所以最小生成树唯一。

#### (b)









#### (c)









### Problem 6

#### 	算法描述

​		因为F最小$\iff$删去F后剩余无环图边集权重和最大$\iff$剩余图为最大生成树

​		因此算法采用$Boruvka$算法生成最大生成树（仅将算法中选取最小向外边改为最大向外边），记录生成树中的边集$E_{tree}$，则所求的集合F为$G.E-E_{tree}$

#### 	伪代码

```
FindF(G,w):
E'= BoruvkaMaxST(G,w);
return G.E-E'
```

#### 	时间复杂度分析

总开销主要为$Boruvka$算法中生成最大生成树的开销，为$O(m\log n)$

### Problem 7

#### (a)

#### 	算法描述

若e不在T中，从T中找到连接e的两个端点的最小路径上的所有顶点，删去这条路径，并对这几个顶点重新生成最小生成树，放回原树中即可

若e在T中，则最小生成树仍为T

#### 	时间复杂度分析

生成MST的时间为$O(m\log n)$，（最坏情况下边e两点之间路径为整棵树），删除和放回操作为$O(m)$的，因此总时间复杂度为$O(m\log n)$



#### (b)

#### 	算法描述

若e不在T中，则由最小生成树性质，T不发生改变。

若e在T中，删去e，再遍历连接当前的两个连通分支的所有边，找出最小的放入最小生成树中即可

#### 	时间复杂度分析

只需对删去e之后的两连通分支之间的边进行遍历即可，找出最小边的时间复杂度为$O(m)$，更换边时间复杂度为$O(1)$，因此总时间复杂度为$O(m)$的

